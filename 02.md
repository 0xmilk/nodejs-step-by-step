# Node.js: Step by Step - NVM and NPM

## Introduction

Hi guys. Well it's been a little while since our last session, and I do apologize for such a long hiatus, but I'm back
now and I'm looking forward to continuing this series on node development.

Today's session will be a little different from the first two. We've got a bit of a taste for node already in the
previous sessions, and now I want to go off on a bit of a tangent and dive into some of the infrastructure that's grown
up around node to help make developing in it much easier. Today will be all about learning a couple of the most
important tools for developing Node applications that will, hopefully, make you much more effective and will also aid
you in the completion of this series.

The tools that we'll be covering today are nvm and npm. The Node Version Manager, or nvm as it is usally refered to, as
the name suggests, is a tool for managing multiple versions of Node. Node is still in it's pre-1.0 phase and, as such,
can be a bit volatile. As a developer it pays to have a way of locking a project into a specific version of Node once
you've started developing with it and nvm is going to be our way of doing that. The npm project, which officially does
not stand for anything, is a package manager. Like gems for Ruby or pip for Python, it allows us to install and manage
any number of third party libraries without all the worries of finding and installing dependencies and so on and so
forth. Finally, as a bonus, we'll put npm to use by installing another third party program from the maker of npm that
should help make developing Node apps much less painful.

So, apologies made and summary out of the way, let's get right down to business.

## Node Version Manager (nvm)

Considering that it's been such a long break since our last session, and, in the interim, Node has advanced from
release 0.4.5 to 0.6.13, I think a good topic to start off with would be the Node Version Manager. As the name
suggests, nvm will allow you to install and switch between several different versions of Node. Coupled with npm, which
we'll be discussing next, you can create virtual environments around specific versions of node and any third party
libraries that you'll be using in your projects. If you're familiar at all with virtualenv for Python, you'll have some
idea of what the combination of these two pieces of software has to offer.

### Installation

The installation of nvm is quite simple, just go to its github page in your browser (you can do so by simply googling
nvm and, most likely, it will be one of the first few results---if not the first). The installation is quite simple,
it's basically a matter of storing the nvm directory somewhere in your filesystem and then sourcing the main shell
script whenever you start a new shell. So, if you have git installed on your computer, you can copy this line here
[copy the install line from the website] and run it at the command line.

    git clone git://github.com/creationix/nvm.git ~/nvm

What this will do is checkout the nvm repository into a hidden directory named .nvm in your home directory. If you
don't have git installed, one option would be to install it (honestly git is a great piece of software to have), but
another option that's a bit faster is just to scroll back up a bit and click on the Downloads link here and then choose
whether you want to download the repository as a zip file or a tarball. Once you've got that download, you'll need to
unzip or untar it and then change its name and location to .nvm in your home directory.

Next, we'll need to add little bit of code to our shell's config file, such as your .bashrc file, to make the
environment aware of nvm. Let's go ahead and open that up now. So, here I'm going to pull up my .bashrc file---you'll
need to place the following somewhere within this file:

    export NVM_HOME="$HOME/.nvm"
    if [[ -f "$NVM_HOME/nvm.sh" ]]; then
        source "$NVM_HOME/nvm.sh"
    fi

All this bit of code here does is, whenever a new shell session is started, it will check for the existence of the
`nvm.sh` file within the `.nvm` directory that you just created. If it exists, it will run the file within the current
shell creating several new shell functions for you to use. Now, you don't actually need to surround the `source`
command with the check for the file's existence since we know it's there, but I like to have it there to keep the shell
from screaming at me whenever I remove or move my .nvm directory for whatever reason. One more thing to notice, is that
you can actually name your nvm directory whatever you want and keep it wherever you like. Calling it .nvm and placing
it in your home directory is the default, but if you prefer to put it somewhere else, all you have to do is just change
the `NVM_HOME` variable in the bit of code above to reflect your preferences. So, feel free to move the nvm folder
around to somewhere else if having a hidden directory in your home directory is not to your liking.

Ok, now that we've got nvm installed, we just need to source our startup file to get nvm to be recognized in the
current shell. To make sure everything worked properly, call `nvm` now and hopefully what you'll see is the help output
for the command.

If you just saw some help information fly across your screen, you're all setup and ready to manage multiple versions of
node.

### Exploring nvm

Now that you have nvm installed, let's play around with it a bit and see what all it has to offer and then get the
lastest version of node installed on our system.

There are a few important commands that you'll probably use quite often. The first of these is the `ls` command. Go
ahead and type `nvm ls` at the command line and take a look at what gets printed out. Not much huh? Just an N/A (or a
dot depending on your shell) and a second line that says `current:`. The reason your not seeing much here is that you
haven't installed node on your system yet. Once you've got at least one node installed, the `ls` command becomes much
more useful by listing all of the currently installed versions of node available for you to choose from as well as the
current version in use and any aliases that you've created. Well I can't think of a better segue than that to start
installing a copy of node. So, let's do that now.

To install a version of node you invoke the `nvm install` command with the version number of the Node you want to
install. For us that will be version 0.6.13, but an important thing to remember here is that the version number must be
prefaced with a 'v' or else the install will not work. So, type the command `nvm install v0.6.13` at your command line
now and you should see the download and installation of begin.

- Viewing which nodes you are using and have installed
- Aliases (stable, dev, default)

## Node Package Manager (NPM)

### Installing packages (local vs global)

    # Checks that the child directory is a subdirectory of the parent
    is_subdirectory() {
        local child="$1"
        local parent="$2"
        if [[ "${child##${parent}}" != "$child" ]]; then
    	    return 0
        else
    	    return 1
        fi
    }

    # Activates a new environment
    activate_env() {
        # Check if the directory we've cd'ed into is a node environment directory
        # (i.e., it contains a node_modules folder) and that a node envrionment
        # does not already exist before creating a new one.
        if [ -d "node_modules" ] && [ -z "$_ENV_DIR" ]; then

            # Save the old PATH variable so we can revert back to it when we leave
            # the environment
    	    export _OLD_PATH="$PATH"

            # An environment is essentially nothing more than an environment
            # variable (_ENV_DIR) pointing the parent directory of our node
            # environment. Create the variable and point it to $PWD.
    	    export _ENV_DIR="$PWD"

            # Add the bin folder for all local NPM installs to the PATH
            export PATH="$(npm bin):$PATH"

            # If an activation script exists, execute it
            if [ -e ".activate" ]; then
    	        source .activate
            fi
        fi
    }

    # Deactivates the current envrionment
    deactivate_env() {
        # Make sure that an envrionment does exist and that the new
        # directory is not a subdirectory of the envrionment directory
        if [ -n "$_ENV_DIR" ] && ! is_subdirectory "$PWD" "$_ENV_DIR"; then

            # Run the deactivation script if it exists
    	    if [[ -e "$_ENV_DIR/.deactivate" ]]; then
    	        source "$_ENV_DIR/.deactivate"
    	    fi

            # Revert back to the original PATH
    	    export PATH="$_OLD_PATH"

            # Destroy the environment
    	    unset _ENV_DIR
    	    unset _OLD_PATH
        fi
    }

    env_cd() {
        builtin cd "$@" && deactivate_env && activate_env
    }

    alias cd="env_cd"


#### Supervisor

[npm]: http://npmjs.org/
[npm-g-vs-l]:http://blog.nodejs.org/2011/03/23/npm-1-0-global-vs-local-installation/

